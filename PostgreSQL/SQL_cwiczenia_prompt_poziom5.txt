Jesteś ekspertem PostgreSQL performance tuning i database administration. Twoim zadaniem jest przygotowanie zaawansowanych ćwiczeń z transakcji, lockingu, dynamicznego SQL i monitoringu na bazie danych AdventureWorks dla PostgreSQL.

# KONTEKST:
- Baza danych: AdventureWorks (PostgreSQL, obraz Docker: chriseaton/adventureworks:postgres)
- Poziom: Expert - Zaawansowane zagadnienia (tydzień 9-10)
- Uczeń zna już: SQL, funkcje, procedury, optymalizację, plany wykonania
- Uczeń ma dostęp do pełnej bazy AdventureWorks na lokalnym PostgreSQL (Docker)
- Uczeń ma uprawnienia superuser (tworzenie rozszerzeń, zmiana konfiguracji)
- Połączenie: host=localhost, port=5432, user=postgres, password=admin123, database=adventureworks

# TEMATY DO POKRYCIA:

## 1. Transakcje i Isolation Levels (MVCC):
- BEGIN / COMMIT / ROLLBACK
- SAVEPOINT name / ROLLBACK TO SAVEPOINT name
- Isolation Levels w PostgreSQL:
  * READ COMMITTED (domyślny w PostgreSQL)
  * REPEATABLE READ (snapshot na początku transakcji)
  * SERIALIZABLE (SSI - Serializable Snapshot Isolation)
  * Uwaga: PostgreSQL NIE ma READ UNCOMMITTED (traktuje jak READ COMMITTED)
- MVCC (Multi-Version Concurrency Control) - jak PostgreSQL zarządza współbieżnością
- Problemy: dirty reads (niemożliwe w PG!), non-repeatable reads, phantom reads, serialization anomalies
- Lost updates problem
- xmin, xmax - wewnętrzne kolumny wersjonowania

## 2. Locking i Blocking:
- Tryby lockowania: ACCESS SHARE, ROW SHARE, ROW EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE, ACCESS EXCLUSIVE
- Row-level locks: FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE, FOR KEY SHARE
- SELECT ... FOR UPDATE / FOR SHARE
- SKIP LOCKED / NOWAIT
- Advisory locks: pg_advisory_lock(), pg_try_advisory_lock()
- Lock monitoring: pg_locks, pg_stat_activity
- Blocking detection
- Lock timeout: SET lock_timeout = '5s';

## 3. Deadlocks:
- Czym jest deadlock w kontekście PostgreSQL
- Automatyczna detekcja deadlocków (deadlock_timeout - domyślnie 1s)
- Log deadlocków (log_lock_waits = on)
- Strategie zapobiegania:
  * Consistent access order
  * Keep transactions short
  * Proper indexing
  * Lower isolation levels (jeśli możliwe)
  * Retry logic w aplikacji
- pg_locks analysis

## 4. Dynamiczny SQL w PL/pgSQL:
- EXECUTE command
- format() z %I (identifier), %L (literal), %s (string)
- EXECUTE ... USING (parametryzacja)
- SQL injection prevention w PostgreSQL
- quote_ident(), quote_literal(), quote_nullable()
- Kiedy używać:
  * Dynamic search conditions
  * Dynamic pivot (crosstab)
  * Meta-programming
  * Admin scripts
- Kiedy NIE używać
- Performance: plan caching vs dynamic execution

## 5. Monitoring i Diagnostyka:
- **pg_stat_activity** - aktywne sesje i zapytania
- **pg_stat_statements** (rozszerzenie) - statystyki zapytań
- **pg_stat_user_tables** - statystyki tabel (seq_scan, idx_scan, dead tuples)
- **pg_stat_user_indexes** - statystyki indeksów
- **pg_stat_bgwriter** - statystyki background writer
- **pg_locks** - aktualne locki
- **pg_stat_replication** - replikacja
- **pg_stat_wal** - statystyki WAL (PostgreSQL 14+)
- **pg_stat_io** - statystyki IO (PostgreSQL 16+)
- **auto_explain** - automatyczne logowanie planów wykonania
- **pg_stat_progress_**** - postęp operacji (VACUUM, CREATE INDEX, etc.)

## 6. VACUUM i Maintenance:
- VACUUM (odzyskiwanie miejsca, aktualizacja visibility map)
- VACUUM FULL (kompaktowanie tabeli - blokuje!)
- VACUUM ANALYZE (vacuum + aktualizacja statystyk)
- Autovacuum - konfiguracja i monitoring
- Dead tuples i bloat
- pg_stat_all_tables (n_dead_tup, last_vacuum, last_autovacuum)
- Monitoring autovacuum

## 7. Partycjonowanie:
- Declarative partitioning (PostgreSQL 10+)
- RANGE, LIST, HASH partitioning
- Partition pruning
- Partitioned indexes
- Kiedy partycjonować (duże tabele, archiwizacja)

## 8. LISTEN / NOTIFY:
- Pub/sub w PostgreSQL
- LISTEN channel
- NOTIFY channel, 'payload'
- pg_notify() function
- Use cases: real-time updates, cache invalidation

# FORMAT ĆWICZEŃ:
Dla każdego ćwiczenia podaj:

## Ćwiczenie [numer]: [Tytuł - problem do rozwiązania]
**Poziom trudności:** [Zaawansowany/Expert/Production-Ready]
**Typ:** [Transactions/Locking/Deadlock/Dynamic SQL/Monitoring]
**Temat:** [Konkretny problem/umiejętność]
**Czas na wykonanie:** [30-60 min]

**Scenariusz produkcyjny:**
[Realistyczny problem z produkcji]
"Użytkownicy zgłaszają timeout'y w aplikacji. DBA zauważył blocking chains w pg_stat_activity..."

**Problem do zdiagnozowania:**
[Szczegółowy opis symptomów]
- Symptom 1: [np. timeouts co 2-3 minuty]
- Symptom 2: [np. high CPU]
- Symptom 3: [np. blocking sessions]

**Zadanie - Faza 1: Setup (Reprodukcja problemu)**
[Kod do symulacji problemu produkcyjnego]

**Zadanie - Faza 2: Diagnoza**
1. Użyj pg_stat_activity / pg_locks do zidentyfikowania problemu
2. Zbierz dowody (plany wykonania, locks, wait events)
3. Zidentyfikuj root cause

**Zadanie - Faza 3: Rozwiązanie**
1. Zaproponuj rozwiązanie
2. Zaimplementuj fix
3. Zweryfikuj że problem zniknął
4. Udokumentuj rozwiązanie

**Zadanie - Faza 4: Prevention**
[Jak zapobiec w przyszłości]

---

### FAZA 1: SETUP - Reprodukcja problemu

```sql
-- ============================================
-- Setup: Symulacja problemu produkcyjnego
-- ============================================

-- Session 1 (Uruchom w jednym oknie psql / pgAdmin)
[Kod Session 1]

-- Session 2 (Uruchom w drugim oknie psql / pgAdmin)
[Kod Session 2]

-- Rezultat: [Opisz co się stanie - deadlock, blocking, etc.]
```

**Co powinieneś zaobserwować:**
[Dokładny opis problemu który wystąpi]

---

### FAZA 2: DIAGNOZA

**Krok 1: Sprawdź aktywne sesje i blocking**
```sql
-- Zidentyfikuj blocking sessions
SELECT
    blocked.pid AS blocked_pid,
    blocked.usename AS blocked_user,
    blocking.pid AS blocking_pid,
    blocking.usename AS blocking_user,
    blocked.query AS blocked_query,
    blocking.query AS blocking_query,
    blocked.wait_event_type,
    blocked.wait_event,
    NOW() - blocked.query_start AS blocked_duration
FROM pg_stat_activity blocked
JOIN pg_locks bl ON bl.pid = blocked.pid
JOIN pg_locks lk ON lk.locktype = bl.locktype
    AND lk.database IS NOT DISTINCT FROM bl.database
    AND lk.relation IS NOT DISTINCT FROM bl.relation
    AND lk.page IS NOT DISTINCT FROM bl.page
    AND lk.tuple IS NOT DISTINCT FROM bl.tuple
    AND lk.virtualxid IS NOT DISTINCT FROM bl.virtualxid
    AND lk.transactionid IS NOT DISTINCT FROM bl.transactionid
    AND lk.classid IS NOT DISTINCT FROM bl.classid
    AND lk.objid IS NOT DISTINCT FROM bl.objid
    AND lk.objsubid IS NOT DISTINCT FROM bl.objsubid
    AND lk.pid != bl.pid
JOIN pg_stat_activity blocking ON lk.pid = blocking.pid
WHERE NOT bl.granted;
```

**Krok 2: Sprawdź aktualne locki**
```sql
-- Szczegóły lockowania
SELECT
    l.locktype,
    l.relation::regclass AS table_name,
    l.mode,
    l.granted,
    l.pid,
    a.usename,
    a.query,
    a.state,
    NOW() - a.query_start AS duration
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation IS NOT NULL
    AND a.datname = current_database()
ORDER BY l.relation, l.pid;
```

**Krok 3: Sprawdź wait events**
```sql
-- Jakie eventy czekają
SELECT
    pid,
    usename,
    wait_event_type,
    wait_event,
    state,
    LEFT(query, 80) AS query_preview,
    NOW() - query_start AS duration
FROM pg_stat_activity
WHERE state != 'idle'
    AND pid != pg_backend_pid()
ORDER BY query_start;
```

**Krok 4: [Dodatkowe kroki diagnostyczne specyficzne dla problemu]**

**Co powinieneś znaleźć:**
[Oczekiwane wyniki diagnostyki]

---

### FAZA 3: ROZWIĄZANIE

**Root Cause Analysis:**
[Szczegółowe wyjaśnienie dlaczego problem wystąpił]

**Rozwiązanie 1: [Nazwa rozwiązania]**
```sql
-- Implementacja rozwiązania
[Kod fix'a]
```

**Uzasadnienie:**
[Dlaczego to rozwiązanie działa]

**Rozwiązanie 2: [Alternatywne rozwiązanie]**
```sql
-- Alternatywna implementacja
[Kod alternatywnego fix'a]
```

**Porównanie rozwiązań:**
| Aspekt | Rozwiązanie 1 | Rozwiązanie 2 |
|--------|---------------|---------------|
| Performance | [+/-] | [+/-] |
| Complexity | [+/-] | [+/-] |
| Maintainability | [+/-] | [+/-] |

---

### FAZA 4: WERYFIKACJA I PREVENTION

**Test: Sprawdź czy problem zniknął**
```sql
-- Ponowne uruchomienie scenariusza
[Test code]

-- Weryfikacja braku blockingu/deadlocków
[Verification queries]
```

**Monitoring setup:**
```sql
-- Włącz logowanie deadlocków
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = '1s';
SELECT pg_reload_conf();

-- Włącz pg_stat_statements (jeśli nie włączone)
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Włącz auto_explain dla wolnych zapytań
ALTER SYSTEM SET auto_explain.log_min_duration = '1s';
ALTER SYSTEM SET auto_explain.log_analyze = on;
-- LOAD 'auto_explain';  -- wymaga restartu lub shared_preload_libraries
```

**Best practices dla zapobiegania:**
1. [Practice 1]
2. [Practice 2]
3. [Practice 3]

---

### Kluczowe koncepcje:

**1. MVCC w PostgreSQL:**
- PostgreSQL NIE blokuje odczytów przez zapisy (i odwrotnie)
- Każda transakcja widzi "snapshot" danych
- Stare wersje wierszy (dead tuples) czyszczone przez VACUUM
- xmin/xmax - identyfikatory transakcji tworzenia/usunięcia wiersza

**2. Isolation Levels w PostgreSQL vs SQL Server:**
| Level | PostgreSQL | SQL Server |
|-------|-----------|------------|
| READ UNCOMMITTED | = READ COMMITTED (brak dirty reads!) | Dirty reads możliwe |
| READ COMMITTED | Domyślny. Snapshot per statement | Domyślny. Lock-based |
| REPEATABLE READ | Snapshot per transaction | Lock-based |
| SERIALIZABLE | SSI (optimistic) | Lock-based (pessimistic) |

**3. PostgreSQL jest MVCC-based:**
- Nie potrzeba NOLOCK (bo odczyty nigdy nie blokują)
- Nie potrzeba READ UNCOMMITTED (bo MVCC zapewnia non-blocking reads)
- REPEATABLE READ jest "darmowy" (snapshot, nie locki)
- SERIALIZABLE używa SSI - optimistic, wykrywa anomalie na COMMIT

---

# ZASADY TWORZENIA ĆWICZEŃ:

## Ogólne zasady:

1. **Realistyczne problemy produkcyjne:**
   - Każde ćwiczenie = problem który występuje w prawdziwej produkcji
   - Hands-on troubleshooting
   - Uczenie metodologii diagnostyki

2. **Multi-faza approach:**
   - Setup: Reprodukuj problem
   - Diagnoza: Znajdź root cause (pg_stat_activity, pg_locks)
   - Fix: Rozwiąż problem
   - Verify: Sprawdź że działa
   - Prevent: Jak zapobiec w przyszłości

3. **Ucz trade-offs:**
   - Nie ma "one size fits all" solutions
   - Każde rozwiązanie ma plusy i minusy
   - Context matters

4. **PostgreSQL-specific concepts:**
   - MVCC zamiast lock-based concurrency
   - VACUUM i dead tuples
   - Advisory locks
   - SKIP LOCKED / NOWAIT
   - LISTEN / NOTIFY

## Dla Transakcji i Isolation Levels:

**Ćwiczenia powinny pokazywać:**

1. **Non-Repeatable Reads (READ COMMITTED):**
   - Symuluj problem (SELECT, potem inny update, potem ten sam SELECT)
   - Jak REPEATABLE READ to rozwiązuje (snapshot)
   - Różnica vs SQL Server (snapshot, nie locki!)

2. **Phantom Reads:**
   - Demonstracja problemu
   - REPEATABLE READ w PostgreSQL JUŻ zapobiega phantoms (snapshot!)
   - SERIALIZABLE dla pełnej izolacji

3. **Serialization Failures:**
   - REPEATABLE READ/SERIALIZABLE mogą rzucić: "could not serialize access"
   - Retry logic w aplikacji jest WYMAGANY
   - SQLSTATE '40001' (serialization_failure) i '40P01' (deadlock_detected)

4. **Lost Updates:**
   - Classic problem
   - SELECT ... FOR UPDATE (pessimistic locking)
   - REPEATABLE READ + retry (optimistic locking)

**Przykładowe scenariusze:**
- Banking: transfer between accounts (lost updates)
- E-commerce: inventory management (phantom reads)
- Reporting: consistent reads (REPEATABLE READ snapshot)

## Dla Lockingu i Blockingu:

**Ćwiczenia powinny pokazywać:**

1. **Blocking Detection:**
   - pg_stat_activity + pg_locks
   - Znajdź blocking session
   - pg_cancel_backend() vs pg_terminate_backend()

2. **Row-level Locking:**
   - SELECT ... FOR UPDATE (exclusive row lock)
   - SELECT ... FOR SHARE (shared row lock)
   - SELECT ... FOR UPDATE SKIP LOCKED (queue pattern!)
   - SELECT ... FOR UPDATE NOWAIT (fail fast)

3. **Advisory Locks:**
   - pg_advisory_lock(key) / pg_advisory_unlock(key)
   - pg_try_advisory_lock(key) (non-blocking)
   - Use case: application-level mutual exclusion
   - Session-level vs transaction-level

4. **Lock Timeout:**
   - SET lock_timeout = '5s';
   - SET statement_timeout = '30s';

**Przykładowe scenariusze:**
- Queue processing z SKIP LOCKED
- Long-running report vs OLTP (PostgreSQL MVCC = brak konfliktu!)
- Batch update causing blocking
- Advisory locks dla distributed locking

## Dla Deadlocków:

**Ćwiczenia MUSZĄ:**

1. **Symulować prawdziwy deadlock:**
```sql
-- Classic deadlock scenario
-- Session 1: UPDATE table1 WHERE id=1; UPDATE table2 WHERE id=1;
-- Session 2: UPDATE table2 WHERE id=1; UPDATE table1 WHERE id=1;
-- PostgreSQL automatycznie wykryje i zabije jedną sesję
```

2. **Sprawdzić logi:**
```sql
-- PostgreSQL loguje deadlocki automatycznie (jeśli log_lock_waits = on)
-- Sprawdź: /var/log/postgresql/ lub docker logs adventureworks

-- Sprawdź deadlock_timeout
SHOW deadlock_timeout;
```

3. **Retry Logic:**
```sql
-- PL/pgSQL retry pattern
CREATE OR REPLACE FUNCTION retry_operation()
RETURNS void AS $$
DECLARE
    v_retries INTEGER := 3;
    v_attempt INTEGER := 0;
BEGIN
    LOOP
        v_attempt := v_attempt + 1;
        BEGIN
            -- operacja która może spowodować deadlock
            PERFORM do_something();
            RETURN;  -- sukces, wychodzimy
        EXCEPTION
            WHEN deadlock_detected OR serialization_failure THEN
                IF v_attempt >= v_retries THEN
                    RAISE;  -- ostatnia próba, rzuć dalej
                END IF;
                RAISE NOTICE 'Attempt % failed, retrying...', v_attempt;
                PERFORM pg_sleep(0.1 * v_attempt);  -- backoff
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

## Dla Dynamicznego SQL:

**Ćwiczenia powinny pokazywać:**

1. **SQL Injection vulnerability i ochrona:**
```sql
-- ŹLE - SQL injection możliwe
EXECUTE 'SELECT * FROM users WHERE name = ''' || p_name || '''';

-- DOBRZE - parametryzacja z USING
EXECUTE 'SELECT * FROM users WHERE name = $1' USING p_name;

-- DOBRZE - format() z %L (literal) i %I (identifier)
EXECUTE format('SELECT * FROM %I WHERE name = %L', p_table, p_name);
```

2. **Dynamic search (optional filters):**
```sql
CREATE FUNCTION search_products(
    p_name TEXT DEFAULT NULL,
    p_category TEXT DEFAULT NULL,
    p_min_price NUMERIC DEFAULT NULL,
    p_max_price NUMERIC DEFAULT NULL
) RETURNS SETOF production.product AS $$
DECLARE
    v_sql TEXT := 'SELECT * FROM production.product WHERE true';
BEGIN
    IF p_name IS NOT NULL THEN
        v_sql := v_sql || format(' AND name ILIKE %L', '%' || p_name || '%');
    END IF;
    IF p_category IS NOT NULL THEN
        v_sql := v_sql || format(' AND productsubcategoryid = %L', p_category);
    END IF;
    IF p_min_price IS NOT NULL THEN
        v_sql := v_sql || format(' AND listprice >= %L', p_min_price);
    END IF;
    IF p_max_price IS NOT NULL THEN
        v_sql := v_sql || format(' AND listprice <= %L', p_max_price);
    END IF;

    RETURN QUERY EXECUTE v_sql;
END;
$$ LANGUAGE plpgsql STABLE;
```

3. **Dynamic pivot z crosstab:**
```sql
-- PostgreSQL używa tablefunc extension
CREATE EXTENSION IF NOT EXISTS tablefunc;

-- Lub dynamicznie z format() + EXECUTE
```

## Dla Monitoringu:

**Ćwiczenia powinny uczyć:**

1. **Finding expensive queries:**
```sql
-- Wymaga rozszerzenia pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Top CPU consuming queries
SELECT
    LEFT(query, 100) AS query_preview,
    calls,
    ROUND(total_exec_time::numeric, 2) AS total_time_ms,
    ROUND(mean_exec_time::numeric, 2) AS avg_time_ms,
    rows,
    ROUND((shared_blks_hit * 100.0 / NULLIF(shared_blks_hit + shared_blks_read, 0))::numeric, 2) AS cache_hit_pct
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;
```

2. **Active sessions analysis:**
```sql
-- Kto co robi
SELECT
    pid,
    usename,
    application_name,
    client_addr,
    state,
    wait_event_type,
    wait_event,
    LEFT(query, 80) AS query_preview,
    NOW() - query_start AS duration,
    NOW() - xact_start AS transaction_duration
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start NULLS LAST;
```

3. **Table bloat i VACUUM status:**
```sql
-- Tabele potrzebujące VACUUM
SELECT
    schemaname,
    relname,
    n_live_tup,
    n_dead_tup,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_pct,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

4. **Cache hit ratio:**
```sql
-- Ogólny cache hit ratio (powinien być > 99%)
SELECT
    SUM(heap_blks_read) AS heap_read,
    SUM(heap_blks_hit) AS heap_hit,
    ROUND(SUM(heap_blks_hit) * 100.0 / NULLIF(SUM(heap_blks_hit) + SUM(heap_blks_read), 0), 2) AS cache_hit_ratio
FROM pg_statio_user_tables;
```

# TYPOWE SCENARIUSZE ĆWICZEŃ:

## Transakcje (3-4 ćwiczenia):

1. **Banking Transfer Simulation:**
   - Transfer between accounts (lost updates)
   - Solution: SELECT FOR UPDATE lub REPEATABLE READ

2. **Non-Repeatable Read showcase:**
   - Session 1: BEGIN → SELECT → (czekaj) → SELECT (inne dane!)
   - Session 2: UPDATE w międzyczasie
   - Fix: REPEATABLE READ

3. **Serialization Failure handling:**
   - SERIALIZABLE transactions conflicting
   - "could not serialize access" error
   - Retry logic

4. **MVCC Deep Dive:**
   - Pokaż xmin, xmax kolumny
   - Dead tuples po UPDATE
   - VACUUM cleanup

## Locking & Blocking (3-4 ćwiczenia):

5. **Blocking Detection i Resolution:**
   - Symuluj blocking (długa transakcja)
   - Znajdź blocking session z pg_stat_activity + pg_locks
   - pg_cancel_backend() vs pg_terminate_backend()

6. **Queue Pattern z SKIP LOCKED:**
   - Tabela z zadaniami
   - Wielu workerów pobiera zadania
   - SELECT FOR UPDATE SKIP LOCKED
   - Brak blockingu!

7. **Advisory Locks:**
   - Application-level mutual exclusion
   - pg_advisory_lock vs pg_try_advisory_lock
   - Session-level vs transaction-level

## Deadlocks (2-3 ćwiczenia):

8. **Classic Two-Table Deadlock:**
   - Reprodukuj deadlock
   - Sprawdź logi PostgreSQL
   - Fix: consistent order

9. **Deadlock z FK (Foreign Key):**
   - INSERT do child + UPDATE parent
   - Brakujący indeks na FK
   - Dodaj indeks

10. **Retry Logic Pattern:**
    - PL/pgSQL retry procedure
    - Application-level handling (w komentarzach dla różnych języków)

## Dynamic SQL (2-3 ćwiczenia):

11. **SQL Injection Demo:**
    - Pokaż jak zhackować z EXECUTE + konkatenacja
    - Fix: format(%L, %I) lub EXECUTE...USING

12. **Dynamic Search:**
    - Optional filters z format()
    - Plan caching considerations

13. **Dynamic Pivot / Crosstab:**
    - tablefunc extension
    - Lub dynamiczny SQL z format()

## Monitoring (3-4 ćwiczenia):

14. **"Server is Slow" Investigation:**
    - pg_stat_activity (co się dzieje)
    - pg_stat_statements (co było wolne)
    - wait events (na co czeka)

15. **Table Maintenance:**
    - Znajdź tabele z bloatem (dead tuples)
    - VACUUM ANALYZE
    - Sprawdź autovacuum config

16. **Index Usage Analysis:**
    - Znajdź unused indexes (pg_stat_user_indexes)
    - Znajdź brakujące indeksy (Seq Scan na dużych tabelach)
    - Priorytetyzuj zmiany

17. **Cache Performance:**
    - Cache hit ratio
    - shared_buffers tuning
    - pg_buffercache extension

# WYMAGANE ELEMENTY W KAŻDYM ROZWIĄZANIU:

- **Setup code** - reprodukcja problemu
- **Diagnostic steps** - jak znaleźć problem (pg_stat_activity, pg_locks)
- **Root cause analysis** - dlaczego problem wystąpił
- **Solution** - fix + uzasadnienie
- **Verification** - sprawdź że działa
- **Prevention** - jak zapobiec w przyszłości
- **Monitoring** - jak monitorować
- **Best practices** - lessons learned
- **Trade-offs** - plusy i minusy rozwiązania
- **Production-ready code** - gotowe do użycia

# BEST PRACTICES DO NAUCZENIA:

## Transaction Best Practices:
1. Keep transactions as short as possible
2. Use lowest isolation level that meets requirements
3. ALWAYS handle serialization_failure (40001) with retry
4. Never wait for user input in transaction
5. REPEATABLE READ w PostgreSQL jest "darmowy" (snapshot, nie locki)

## Locking Best Practices:
1. PostgreSQL MVCC = readers never block writers (i odwrotnie)
2. Nie potrzebujesz NOLOCK - PostgreSQL domyślnie nie blokuje odczytów
3. Używaj SELECT FOR UPDATE SKIP LOCKED do queue pattern
4. Advisory locks do application-level locking
5. SET lock_timeout aby uniknąć nieskończonego czekania

## Deadlock Best Practices:
1. Access objects in consistent order
2. Keep transactions short
3. Proper indexing (szczególnie na FK kolumnach!)
4. Handle deadlocks w aplikacji (retry logic)
5. Monitor: log_lock_waits = on, deadlock_timeout

## Dynamic SQL Best Practices:
1. ZAWSZE używaj format(%L, %I) lub EXECUTE...USING
2. NIGDY nie konkatenuj user input bezpośrednio
3. quote_ident() dla nazw obiektów, quote_literal() dla wartości
4. Waliduj input
5. Dokumentuj DLACZEGO dynamiczny SQL jest potrzebny

## Monitoring Best Practices:
1. Włącz pg_stat_statements w produkcji
2. Monitoruj dead tuples i autovacuum
3. Cache hit ratio > 99%
4. Regularny ANALYZE po dużych zmianach danych
5. log_min_duration_statement do logowania wolnych zapytań

# INSTRUKCJA:
Gdy użytkownik poprosi o ćwiczenia, wygeneruj serię 5-10 ćwiczeń zgodnie z powyższym formatem.

Każde ćwiczenie MUSI:
1. Symulować realny problem produkcyjny
2. Uczyć metodologii troubleshootingu
3. Pokazywać diagnostic queries (pg_stat_activity, pg_locks)
4. Prezentować multiple solutions z trade-offs
5. Być hands-on (setup → diagnose → fix → verify)
6. Uczyć prevention i monitoring
7. Być production-ready

Progresja:
- Start: Basic transactions, MVCC concepts
- Middle: Deadlocks, isolation levels, blocking troubleshooting
- Advanced: Complex scenarios, dynamic SQL, production monitoring
- Expert: Multi-faceted problems, performance tuning, capacity planning

Teraz wygeneruj zaawansowane ćwiczenia dla AdventureWorks (PostgreSQL), skupiając się na [TEMAT - będzie podany przez użytkownika].

---

# JAK UŻYWAĆ:

Skopiuj cały powyższy tekst do nowej konwersacji z AI i dodaj konkretne żądanie:

**Przykłady:**

"Wygeneruj 5 ćwiczeń na transakcje i isolation levels w PostgreSQL - od MVCC basics do SERIALIZABLE."

"Wygeneruj 8 ćwiczeń:
- 2 ćwiczenia: Isolation levels (non-repeatable reads, serialization failures)
- 2 ćwiczenia: Deadlock troubleshooting
- 2 ćwiczenia: Dynamic SQL security (format, EXECUTE USING)
- 2 ćwiczenia: Monitoring (pg_stat_activity, pg_stat_statements)"

"Wygeneruj ćwiczenia na troubleshooting production issues - blocking, deadlocks, slow queries."

"Przygotuj ćwiczenia na SKIP LOCKED queue pattern i advisory locks."

"Kompletny zestaw dla poziomu 5 - 10 ćwiczeń pokrywających wszystkie tematy."

"Wygeneruj ćwiczenia na VACUUM, autovacuum i table maintenance."

"Ćwiczenia pokazujące SQL injection w PL/pgSQL i jak się przed tym bronić."

---

# BEZPIECZEŃSTWO I OSTROŻNOŚĆ:

**WAŻNE OSTRZEŻENIA:**

1. **Deadlock exercises:**
   - Uruchamiaj tylko na DEV/TEST (Docker)
   - Nigdy na produkcji
   - Używaj małych tabel testowych

2. **Lock timeouts:**
   - Zawsze ustawiaj lock_timeout w ćwiczeniach
   - SET lock_timeout = '10s';
   - Zapobiega "zawieszeniu" sesji

3. **Dynamic SQL:**
   - SQL injection jest REALNYM zagrożeniem
   - ZAWSZE format(%L, %I) lub EXECUTE...USING
   - Waliduj input

4. **pg_terminate_backend():**
   - Zabija sesję natychmiast
   - Preferuj pg_cancel_backend() (anuluje zapytanie, nie sesję)
   - Na produkcji sprawdź co robi sesja PRZED kill

5. **Isolation levels:**
   - SERIALIZABLE może generować serialization errors
   - MUSISZ mieć retry logic
   - Test performance impact

6. **VACUUM FULL:**
   - Blokuje tabelę na czas operacji!
   - Nie używaj na produkcji w godzinach szczytu
   - Alternatywa: pg_repack (extension)

7. **Zmiany konfiguracji (ALTER SYSTEM):**
   - Niektóre wymagają restartu PostgreSQL
   - Niektóre wystarczy pg_reload_conf()
   - Zawsze sprawdź w dokumentacji

# PRZYDATNE ROZSZERZENIA PostgreSQL:

```sql
-- Statystyki zapytań
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Crosstab / pivot
CREATE EXTENSION IF NOT EXISTS tablefunc;

-- Buffer cache inspection
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

-- Dodatkowe statystyki
CREATE EXTENSION IF NOT EXISTS pgstattuple;

-- Auto explain (wymaga shared_preload_libraries)
-- ALTER SYSTEM SET shared_preload_libraries = 'auto_explain, pg_stat_statements';
```
